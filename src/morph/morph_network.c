/**
 * morph_network.c - Network layer morphing integration with Cowrie
 * 
 * This module integrates network variations generated by network.c
 * into the Cowrie honeypot by generating custom command outputs.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "network.h"
#include "utils.h"

#define COWRIE_TXTCMDS_DIR "services/cowrie/etc/txtcmds"
#define COWRIE_DYNAMIC_DIR "build/cowrie-dynamic"

/**
 * Create a dynamic command directory for session-specific responses
 */
int create_cowrie_dynamic_dir(void) {
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "mkdir -p %s/bin %s/sbin", COWRIE_DYNAMIC_DIR, COWRIE_DYNAMIC_DIR);
    return system(cmd) == 0 ? 0 : -1;
}

/**
 * Generate ifconfig command output and write to Cowrie txtcmds
 */
int generate_cowrie_ifconfig(network_config_t* config) {
    if (!config) return -1;

    char ifconfig_output[4096];
    if (generate_ifconfig_output(config, ifconfig_output, sizeof(ifconfig_output)) <= 0) {
        log_event_level(LOG_ERROR, "Failed to generate ifconfig output");
        return -1;
    }

    // Write to file that Cowrie can use
    char ifconfig_path[512];
    snprintf(ifconfig_path, sizeof(ifconfig_path), "%s/sbin/ifconfig", COWRIE_DYNAMIC_DIR);

    FILE* f = fopen(ifconfig_path, "w");
    if (!f) {
        log_event_level(LOG_WARN, "Could not write ifconfig command to Cowrie");
        return -1;
    }

    fprintf(f, "%s", ifconfig_output);
    fclose(f);

    log_event_level(LOG_INFO, "Generated network ifconfig output");
    return 0;
}

/**
 * Generate route command output
 */
int generate_cowrie_route(network_config_t* config) {
    if (!config) return -1;

    char route_output[2048];
    if (generate_route_output(config, route_output, sizeof(route_output)) <= 0) {
        log_event_level(LOG_ERROR, "Failed to generate route output");
        return -1;
    }

    char route_path[512];
    snprintf(route_path, sizeof(route_path), "%s/bin/route", COWRIE_DYNAMIC_DIR);

    FILE* f = fopen(route_path, "w");
    if (!f) {
        log_event_level(LOG_WARN, "Could not write route command to Cowrie");
        return -1;
    }

    fprintf(f, "%s", route_output);
    fclose(f);

    log_event_level(LOG_INFO, "Generated network route output");
    return 0;
}

/**
 * Generate arp command output
 */
int generate_cowrie_arp(network_config_t* config) {
    if (!config) return -1;

    char arp_output[2048];
    if (generate_arp_output(config, arp_output, sizeof(arp_output)) <= 0) {
        log_event_level(LOG_ERROR, "Failed to generate ARP output");
        return -1;
    }

    char arp_path[512];
    snprintf(arp_path, sizeof(arp_path), "%s/sbin/arp", COWRIE_DYNAMIC_DIR);

    FILE* f = fopen(arp_path, "w");
    if (!f) {
        log_event_level(LOG_WARN, "Could not write arp command to Cowrie");
        return -1;
    }

    fprintf(f, "%s", arp_output);
    fclose(f);

    log_event_level(LOG_INFO, "Generated network ARP output");
    return 0;
}

/**
 * Generate netstat output
 */
int generate_cowrie_netstat(network_config_t* config) {
    if (!config) return -1;

    char netstat_output[1024];
    if (generate_netstat_output(config, netstat_output, sizeof(netstat_output)) <= 0) {
        log_event_level(LOG_ERROR, "Failed to generate netstat output");
        return -1;
    }

    char netstat_path[512];
    snprintf(netstat_path, sizeof(netstat_path), "%s/bin/netstat", COWRIE_DYNAMIC_DIR);

    FILE* f = fopen(netstat_path, "w");
    if (!f) {
        log_event_level(LOG_WARN, "Could not write netstat command to Cowrie");
        return -1;
    }

    fprintf(f, "%s", netstat_output);
    fclose(f);

    log_event_level(LOG_INFO, "Generated network netstat output");
    return 0;
}

/**
 * Generate /proc/net/route content
 */
int generate_cowrie_proc_route(network_config_t* config) {
    if (!config) return -1;

    char proc_route[2048];
    strcpy(proc_route,
           "Iface\tDestination\tGateway\t\tFlags\tRefCnt\tUse\tMetric\tMask\t\tMTU\tWindow\tIRTT\n");

    char entry[256];
    for (int i = 0; i < config->routing_count; i++) {
        routing_entry_t* route = &config->routing_table[i];
        snprintf(entry, sizeof(entry),
                 "%s\t00000000\t0101A8C0\t0000\t0\t0\t0\t00000000\t0\t0\t0\n",
                 route->interface);  // Simplified hex format
        strcat(proc_route, entry);
    }

    char proc_path[512];
    snprintf(proc_path, sizeof(proc_path), "%s/proc_net_route", COWRIE_DYNAMIC_DIR);

    FILE* f = fopen(proc_path, "w");
    if (!f) return -1;

    fprintf(f, "%s", proc_route);
    fclose(f);

    log_event_level(LOG_INFO, "Generated /proc/net/route output");
    return 0;
}

/**
 * Morph network configuration and update Cowrie
 */
int morph_network_config(const char* base_ip) {
    // Create network config
    network_config_t* config = create_network_config(base_ip);
    if (!config) {
        log_event_level(LOG_ERROR, "Failed to create network config");
        return -1;
    }

    // Generate variations
    generate_interface_variations(config);
    generate_routing_variations(config);
    generate_arp_variations(config);

    // Create dynamic command directory
    if (create_cowrie_dynamic_dir() != 0) {
        log_event_level(LOG_WARN, "Failed to create Cowrie dynamic directory");
    }

    // Generate all command outputs
    int result = 0;
    result |= generate_cowrie_ifconfig(config);
    result |= generate_cowrie_route(config);
    result |= generate_cowrie_arp(config);
    result |= generate_cowrie_netstat(config);
    result |= generate_cowrie_proc_route(config);

    // Save configuration for reference
    char* json = serialize_network_config(config);
    if (json) {
        char json_path[512];
        snprintf(json_path, sizeof(json_path), "%s/network-config.json", COWRIE_DYNAMIC_DIR);
        FILE* f = fopen(json_path, "w");
        if (f) {
            fprintf(f, "%s", json);
            fclose(f);
        }
        free(json);
    }

    free_network_config(config);

    if (result == 0) {
        log_event_level(LOG_INFO, "Network morphing complete");
    } else {
        log_event_level(LOG_WARN, "Network morphing completed with errors");
    }

    return result;
}
